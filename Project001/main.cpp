int main()
{
	int i = 0;
	unsigned char c = 0;
	char b = 0;
	c = 0;
	c = -1;

	b = 255;
	// 양수 unsigned signed:양/음수
	// 정수형 : char(1), short(2), int(4), long(4), long long(4)
	// 실수형 : float(4), double(8)

	// 1bit
	// 1byte = 8bit
	// 1kb = 1024byte = 2^10
	// 1mb = 1024kb
	// 1gb = 1024mb
	// 1tb = 1024 gb
	// 음의 정수 찾기(2의 보수법) 1111 1110
	//부호반전후 1을 더한다          0000 0010

	/*실수의 표현방식 우리가 아는 실수의 개념은 1과0사이에도 무한한 수들이 있다
	* 하지만 현실적으로 메모리 제한이 있는 한계 때문에 부동소수점을 이용해 표현한다.
	* 정수와 실수는 표현방식이 다르다는 점을 인지할 것 그래서 변수를 설정할때 사용자는 
	* 정수또는 실수로 통합해줘야 한다. 이는 데이터 처리 방식이 다르기 때문이다.
	*/

	int a = 4 + (int)4.0;
	/*위의 예시처럼 정수와 실수로 연산할 경우 현제 자료형이 정수형이니 실수형이 
	정수로 바뀌는 형변환 연산이 눈에 보이지 않지만 작동하고 있다. 의도한 경우가 아니라면
	이런 메모리 낭비를 	없애기 위해서 변수 수치는 통합하는 것이 좋다*/
	/*부동소수점	부호, 지수, 기수로 나뉜다.*/
	/*실수를 이용할 때 정밀도를 조심해야 한다*/
	
	float f = 10.2415f + (float)20;/* 두 표현방식의 피 연산자가 연산될 때 명시적으로 변환하자* /
	실수를  상수로 넣을 때 f는 플롯 안적으면 double				   
				   
	 /*연산자
	대입연산자 =

	산술연산자
	+, -, *,/,%(모듈러스, 나머지, 피연산자가 모두 정수 일때만 사용가능)
	++, -- (증감연산자)
	*/
	int data = 10 + 10;
	/*data + 20; 대입연산자로 넣지 않으면 40이란 결과는 날라감 그렇기 때문에 * /
	data = data + 20;/*또는*/
	data += 20;/*로 해준다*/

	/*정수, 실수의 나눗셈 두가지 케이스가 나온다
	실수끼리의 (모듈러)나머지 연산은 할수 없다*/
	data = 10 / 3;
	data = 10 % 3;
	/*data = 10. % 3.;
	자료형 타입이 정수형이라 형변환 해줌 소수점뒤는 손실*/
	data = (int)(10. / 3.);/*의도하는경우 이렇게 명시해 주자*/

	data = 0; 
	data++;
	data--;/*한단계 증가한다. 이 단계의 기준은 상황에 따라 다르다(포인터 때문, 기본 자료타입에서는 증감이 맞다)*/
   

	++data; // 전위(전치)
	data++; // 후위(후치)
	/*위치에 따라 우선순위가 바뀐다.
	후치의 경우 모든 가장 순서가 늦다*/
	a = 10;
	data = a++;

	a = 10;
	data = ++a;
	/*전위의 경우 11로 적용됨을 알 수 있다*/
	/*대입연산과 다르게 실직적인 변수값을 증가시킨다.
	증감연산자는 되도록 전위로 사용하도록 한다 나중에 클래스나 구조체에 오퍼레이터(효율이 안좋은 함수를)실수로 호출할 수 있기 때문
	연산자 오버로딩을 할 때 상기해야할 내용*/

	//논리 연산자 (구문이 있는데 조건문과 삼항연산자가 존재하며 연계되서 많이 사용된다.)
	// 참, 거짓
	// !(역)리버스, (&&)합and, ||(합)or
	//참(true), 거짓(false)
	//1=참=true 0이아닌 모든수
	//거짓=0=false
	//bool , 
	bool turefalse = false;//c에서는 전처리기로 사용 타입재정리해서
	bool IsTrue = 100;
	 
	IsTrue = true;

	IsTrue = !IsTrue;

	int iTrue = 100; //반전이 일반 정수형에도 적용된다.
	iTrue = !true;


	iTrue = 100 && 200; //둘다참이니 1을 준다 
	iTrue = 0 || 0;

	//비교 연산자
	// == 양쪽 피연산자가 같은지 
	// != 양쪽 피연산자가 다른지
	// <,>,>=,<=
	// 비교 구문
	// if, else
	data = 0;
	if(0 && 200)
	{
		data = 100;

	}

	if (data == 100)
	{
		// if가 참이면 수행
	}
	else if (100)
	{
	}
	else
	{
		// if가 거짓이면 수행
	}
	data = 30;
	if (data == 10 || data == 20 || data == 30)
	{
	}
	else
	{
	}

			// swich case
			int bTest = 20;
			switch (bTest)
			{
			case 10:
			case 20:
	
			default:
				break;

			}
	int iTest = 10;
	if (iTest == 10)
	{
	}
	else if (iTest == 20)
	{

	}
	// 삼항 연산자
	//	:?
	iTest == 20 ? iTest = 100 : iTest = 200;

	if (iTest == 20)
	{
		iTest = 100;
	}
	else
	{
		iTest = 200;
	}
		return 0;
}	