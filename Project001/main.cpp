int main()
{
	int i = 0;
	unsigned char c = 0;
	char b = 0;
	c = 0;
	c = -1;

	b = 255;
	// 양수 unsigned signed:양/음수
	// 정수형 : char(1), short(2), int(4), long(4), long long(4)
	// 실수형 : float(4), double(8)

	// 1bit
	// 1byte = 8bit
	// 1kb = 1024byte = 2^10
	// 1mb = 1024kb
	// 1gb = 1024mb
	// 1tb = 1024 gb
	// 음의 정수 찾기(2의 보수법) 1111 1110
	//부호반전후 1을 더한다          0000 0010

	/*실수의 표현방식 우리가 아는 실수의 개념은 1과0사이에도 무한한 수들이 있다
	* 하지만 현실적으로 메모리 제한이 있는 한계 때문에 부동소수점을 이용해 표현한다.
	* 정수와 실수는 표현방식이 다르다는 점을 인지할 것 그래서 변수를 설정할때 사용자는 
	* 정수또는 실수로 통합해줘야 한다. 이는 데이터 처리 방식이 다르기 때문이다.
	*/

	int a = 4 + (int)4.0;
	/*위의 예시처럼 정수와 실수로 연산할 경우 현제 자료형이 정수형이니 실수형이 
	정수로 바뀌는 형변환 연산이 눈에 보이지 않지만 작동하고 있다. 의도한 경우가 아니라면
	이런 메모리 낭비를 	없애기 위해서 변수 수치는 통합하는 것이 좋다*/
	/*부동소수점	부호, 지수, 기수로 나뉜다.*/
	/*실수를 이용할 때 정밀도를 조심해야 한다*/
	
	float f = 10.2415f + (float)20;/* 두 표현방식의 피 연산자가 연산될 때 명시적으로 변환하자* /
	실수를  상수로 넣을 때 f는 플롯 안적으면 double				   
				   
	 /*연산자
	대입연산자 =

	산술연산자
	+, -, *,/,%(모듈러스, 나머지, 피연산자가 모두 정수 일때만 사용가능)
	++, -- (증감연산자)
	*/
	int data = 10 + 10;
	/*data + 20; 대입연산자로 넣지 않으면 40이란 결과는 날라감 그렇기 때문에 * /
	data = data + 20;/*또는*/
	data += 20;/*로 해준다*/

	/*정수, 실수의 나눗셈 두가지 케이스가 나온다
	실수끼리의 (모듈러)나머지 연산은 할수 없다*/
	data = 10 / 3;
	data = 10 % 3;
	/*data = 10. % 3.;
	자료형 타입이 정수형이라 형변환 해줌 소수점뒤는 손실*/
	data = (int)(10. / 3.);/*의도하는경우 이렇게 명시해 주자*/

	data = 0; 
	data++;
	data--;/*한단계 증가한다. 이 단계의 기준은 상황에 따라 다르다(포인터 때문, 기본 자료타입에서는 증감이 맞다)*/
   

	++data; // 전위(전치)
	data++; // 후위(후치)
	/*위치에 따라 우선순위가 바뀐다.
	후치의 경우 모든 가장 순서가 늦다*/
	a = 10;
	data = a++;

	a = 10;
	data = ++a;
	/*전위의 경우 11로 적용됨을 알 수 있다*/
	/*대입연산과 다르게 실직적인 변수값을 증가시킨다.
	증감연산자는 되도록 전위로 사용하도록 한다 나중에 클래스나 구조체에 오퍼레이터(효율이 안좋은 함수를)실수로 호출할 수 있기 때문
	연산자 오버로딩을 할 때 상기해야할 내용*/

	//논리 연산자 (구문이 있는데 조건문과 삼항연산자가 존재하며 연계되서 많이 사용된다.)
	// 참, 거짓
	// !(역)리버스, (&&)합and, ||(합)or
	//참(true), 거짓(false)
	//1=참=true 0이아닌 모든수
	//거짓=0=false
	//bool , 
	bool turefalse = false;//c에서는 전처리기로 사용 타입재정리해서
	bool IsTrue = 100;
	 
	IsTrue = true;

	IsTrue = !IsTrue;

	int iTrue = 100; //반전이 일반 정수형에도 적용된다.
	iTrue = !true;


	iTrue = 100 && 200; //둘다참이니 1을 준다 
	iTrue = 0 || 0;

	//비교 연산자
	// == 양쪽 피연산자가 같은지 
	// != 양쪽 피연산자가 다른지
	// <,>,>=,<=
	// 비교 구문
	// if, else
	data = 0;
	if(0 && 200)
	{
		data = 100;

	}

	if (data == 100)
	{
		// if가 참이면 수행
	}
	else if (100)
	{
	}
	else
	{
		// if가 거짓이면 수행
	}
	data = 30;
	if (data == 10 || data == 20 || data == 30)
	{
	}
	else
	{
	}

			// swich case
			int bTest = 20;
			switch (bTest)
			{
			case 10:
			case 20:
	
			default:
				break;

			}
	int iTest = 10;
	if (iTest == 10)
	{
	}
	else if (iTest == 20)
	{

	}
	// 삼항 연산자
	//	:?
	iTest == 20 ? iTest = 100 : iTest = 200;

	if (iTest == 20)
	{
		iTest = 100;
	}
	else
	{
		iTest = 200;
	}
		return 0;
}	

//배열안에 짝수로 채우기
//while문 사용해서 채우기
//짝수 찾는 조건
//while탈출 구문 생각 할 것 
int main()
{
	int a = 0;
	unsigned b = 0;
	char c = 0;
	b = 0;
	b = -1;
	c = 255;// unsiged 를 작성하지 않았기 때문에 127이후부터는 음수로 보인다

	/*
	양수 unsigned , 음수 signed
	정수형 char(1), short(2), int(4), long(4), long long(4)
	실수형 float(4), double(8)
	-------------------------------------------------------------------------------
	1bit
	1byte= 8bit
	1kb =1024byte=2^10
	1mb =1024kb
	1gb = 1024mb
	1tb = 1024gb
	음의 정수 찾기(2의 보수법) 1111 1110
	부호반전후 1을 더한다         0000 0010
	-------------------------------------------------------------------------------
	실수의 표현방식
	1과 0사이의 무한한 수들이 존재
	현실에서는 메모리의 한계 때문에 부동소수점을 이용해 표현
	정수와 실수는 표현방식이 다르다는 점을 인지
	위 근거로 사용자는 변수를 사용할 때 정수 또는 실수로 통합해주는 것이 좋다.
	*/

	int d = 4 + (int)4.1;

	/*
	위의 예시처럼 정수와 실수로 연산할 경우
	실수형이 정수로 바뀌는 형변환 연산이 동작하고 있다.(눈에는 안보이지만)
	의도한 경우가 아니라면 이런 메모리 낭비를 없애기 위해서 표현방식을 통합해야 한다.
	*/

	float e = 10.2415f + (float)20.1;

	/*
	부동소수점은 부호, 지수 , 기수로 나뉜다.
	실수를 이용할 때는 정밀도를 조심해야 한다.
	두 표현 방식의 피 연산자가 연산될 때 명시적으로 변환하자
	실수를 상수로 넣을 때 f는 float 안적으면 double로 자동변환
	-------------------------------------------------------------------------------
	연산자

	대입연산자
	=

	산술연산자
	+,-,/,*.%(모듈러스, 나머지, 피연산자가 모두 정수 일 때만 사용가능)
	++,--(증감연산자)
	*/
	int data = 10 + 10;
	/*
	data +20;
	대입연산자로 넣지 않으면 결과값이 저장되지 않음 그렇기 때문에
	data = data+20; 또는
	data += 20; 으로 표시해줘야 한다.
	*/
	data = data + 20;
	data += 20;

	/*
	정수, 실수의 나눗셈 두 가지 케이스가 나온다
	실수끼리의 (모듈러)나머지 연산은 할 수 없다.
	*/
	data = 10 / 3;
	data = 10 % 3;

	/*
	data = 10. % 3.;
	모듈러스 연산에서
	위 연산자 모두 실수형이라 연산이 되지 않는다
	-------------------------------------------------------------------------------
	나눗셈을 실수로 진행시킬경우 자동으로 정수형으로 변환한다.(이때 소수점뒤는 소실)
	(int)로 명시해주지 않으면 기본double형으로 변환해준다
	뒤에 f를 붙여서 float형으로 변환 가능
	*/
	data = (int)(10. / 3.);

	data = 0;
	data++;
	data--;
	/*
	기존 단계에서 한 단계 증가한는 개념
	단계의 기준은 상황에 따라 다르다.(포인터 때문 기본 자료형 타입에서는 증감으로 본다)
	*/

	++data;//전위(전치)
	data++;//후위(후치)
	/*
	위치에 따라 우선순위가 바뀐다.
	전치의 경우 해당 코드줄에 들어가자 마자 실행
	후치의 경우 모든 가장 순서가 늦다.
	*/

	{
		a = 10;
		data = a++;
		a = 10;
		data = ++a;
	}
	/*
	전위의 경우 11로 적용됨을 알 수 있다.
	대입연산과 다르게 실질적인 변수 값을 증가시킨다.
	증감연산자는 되도록 전위로 사용하도록 한다.
	나중에 클래스나 구조체에 오퍼레이터(효율이 안좋은 함수를) 실수로 호출할 수 있기 때문
	연산자 오버로딩을 할 때 상기해야 할 내용
	-------------------------------------------------------------------------------
	논리연산자(조건문과 삼항연산자가 존재하며 연계되어 많이 사용된다.)
	참, 거짓
	!, &&, ||  =  역, 곱, 합
	참(true), 거짓(false)
	1(0이외의 모든 것), 0
	bool 함수
	*/
	bool truefalse = false; //c에서는 bool함수가 없어서 전처리기로 타입재정리를 해서 사용했다.
	bool isTrue = 100;//참

	isTrue = true;//참

	isTrue = !isTrue;//참의 반대로 대입되니 false
	{
		int isTrue = 100;//반전이 일반 정수형에도 적용된다.
		isTrue = !true;

		isTrue = 100 && 200;//둘 다 참이니 1을 준다.
		isTrue = 0 || 0; //둘 중 하나라도 참이 아니니 거짓이다

	}

	//비교 연산자
	// == 양쪽 피연산자가 같은지 
	// != 양쪽 피연산자가 다른지
	// <,>,>=,<=
	// 비교구문 
	// if, else
	data = 0;
	if (0 && 200)
	{
		data = 100;
	}

	if (data == 100)
	{
		// if가 참이면 수행
	}

}