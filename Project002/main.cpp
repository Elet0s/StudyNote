//배열안에 짝수로 채우기
//while문 사용해서 채우기
//짝수 찾는 조건
//while탈출 구문 생각 할 것 
int main()
{
	int a = 0;
	unsigned b = 0;
	char c = 0;
	b = 0;
	b = -1;
	c = 255;// unsiged 를 작성하지 않았기 때문에 127이후부터는 음수로 보인다

	/*
	양수 unsigned , 음수 signed
	정수형 char(1), short(2), int(4), long(4), long long(4)
	실수형 float(4), double(8)
	-------------------------------------------------------------------------------
	1bit
	1byte= 8bit
	1kb =1024byte=2^10
	1mb =1024kb
	1gb = 1024mb
	1tb = 1024gb
	음의 정수 찾기(2의 보수법) 1111 1110
	부호반전후 1을 더한다         0000 0010
	-------------------------------------------------------------------------------
	실수의 표현방식
	1과 0사이의 무한한 수들이 존재
	현실에서는 메모리의 한계 때문에 부동소수점을 이용해 표현
	정수와 실수는 표현방식이 다르다는 점을 인지
	위 근거로 사용자는 변수를 사용할 때 정수 또는 실수로 통합해주는 것이 좋다.
	*/

	int d = 4 + (int)4.1;

	/*
	위의 예시처럼 정수와 실수로 연산할 경우
	실수형이 정수로 바뀌는 형변환 연산이 동작하고 있다.(눈에는 안보이지만)
	의도한 경우가 아니라면 이런 메모리 낭비를 없애기 위해서 표현방식을 통합해야 한다.
	*/

	float e = 10.2415f + (float)20.1;

	/*
	부동소수점은 부호, 지수 , 기수로 나뉜다.
	실수를 이용할 때는 정밀도를 조심해야 한다.
	두 표현 방식의 피 연산자가 연산될 때 명시적으로 변환하자
	실수를 상수로 넣을 때 f는 float 안적으면 double로 자동변환
	-------------------------------------------------------------------------------
	연산자

	대입연산자
	=

	산술연산자
	+,-,/,*.%(모듈러스, 나머지, 피연산자가 모두 정수 일 때만 사용가능)
	++,--(증감연산자)
	*/
	int data = 10 + 10;
	/*
	data +20;
	대입연산자로 넣지 않으면 결과값이 저장되지 않음 그렇기 때문에
	data = data+20; 또는
	data += 20; 으로 표시해줘야 한다.
	*/
	data = data + 20;
	data += 20;

	/*
	정수, 실수의 나눗셈 두 가지 케이스가 나온다
	실수끼리의 (모듈러)나머지 연산은 할 수 없다.
	*/
	data = 10 / 3;
	data = 10 % 3;

	/*
	data = 10. % 3.;
	모듈러스 연산에서
	위 연산자 모두 실수형이라 연산이 되지 않는다
	-------------------------------------------------------------------------------
	나눗셈을 실수로 진행시킬경우 자동으로 정수형으로 변환한다.(이때 소수점뒤는 소실)
	(int)로 명시해주지 않으면 기본double형으로 변환해준다
	뒤에 f를 붙여서 float형으로 변환 가능
	*/
	data = (int)(10. / 3.);

	data = 0;
	data++;
	data--;
	/*
	기존 단계에서 한 단계 증가한는 개념
	단계의 기준은 상황에 따라 다르다.(포인터 때문 기본 자료형 타입에서는 증감으로 본다)
	*/

	++data;//전위(전치)
	data++;//후위(후치)
	/*
	위치에 따라 우선순위가 바뀐다.
	전치의 경우 해당 코드줄에 들어가자 마자 실행
	후치의 경우 모든 가장 순서가 늦다.
	*/

	{
		a = 10;
		data = a++;
		a = 10;
		data = ++a;
	}
	/*
	전위의 경우 11로 적용됨을 알 수 있다.
	대입연산과 다르게 실질적인 변수 값을 증가시킨다.
	증감연산자는 되도록 전위로 사용하도록 한다.
	나중에 클래스나 구조체에 오퍼레이터(효율이 안좋은 함수를) 실수로 호출할 수 있기 때문
	연산자 오버로딩을 할 때 상기해야 할 내용
	-------------------------------------------------------------------------------
	논리연산자(조건문과 삼항연산자가 존재하며 연계되어 많이 사용된다.)
	참, 거짓
	!, &&, ||  =  역, 곱, 합
	참(true), 거짓(false)
	1(0이외의 모든 것), 0
	bool 함수
	*/
	bool truefalse = false; //c에서는 bool함수가 없어서 전처리기로 타입재정리를 해서 사용했다.
	bool isTrue = 100;//참

	isTrue = true;//참

	isTrue = !isTrue;//참의 반대로 대입되니 false
	{
		int isTrue = 100;//반전이 일반 정수형에도 적용된다.
		isTrue = !true;

		isTrue = 100 && 200;//둘 다 참이니 1을 준다.
		isTrue = 0 || 0; //둘 중 하나라도 참이 아니니 거짓이다

	}

	//비교 연산자
	// == 양쪽 피연산자가 같은지 
	// != 양쪽 피연산자가 다른지
	// <,>,>=,<=
	// 비교구문 
	// if, else
	data = 0;
	if (0 && 200)
	{
		data = 100;
	}

	if (data == 100)
	{
		// if가 참이면 수행
	}

}